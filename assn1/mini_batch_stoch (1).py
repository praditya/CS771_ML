# -*- coding: utf-8 -*-
"""Mini_batch_stoch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f7UK-VAQWGwxTzWjpmZ5Al31ZJPRUPYM
"""

import os
os.chdir('/content/drive/My Drive/assn1/')
import random
import cs771
from cs771 import helloWorld as hW
from cs771 import utils as ut

from google.colab import drive
drive.mount('/content/drive')

# Sir's Code


import numpy as np
from submit import solver

# Find out how much loss is the learnt model incurring?
# def getObjValue( X, y, wHat ):
# 	lassoLoss = np.linalg.norm( wHat, 1 ) + pow( np.linalg.norm( X.dot( wHat ) - y, 2 ), 2 )
# 	return lassoLoss

# Find out how far is the learnt model from the true one in terms of Euclidean distance
def getModelError( wHat, wAst ):
	return np.linalg.norm( wHat - wAst, 2 )

# # Force the learnt model to become sparse and then see how well it approximates the true model
# def getSupportError( wHat, wAst, k ):
# 	# Find the k coordinates where the true model has non-zero values
# 	idxAst = np.abs( wAst ).argsort()[::-1][:k]
# 	# Find the k coordinates with largest values (absolute terms) in the learnt model
# 	idxHat = np.abs( wHat ).argsort()[::-1][:k]
	
# 	# Set up indicator arrays to find the diff between the two
# 	# Could have used Python's set difference function here as well
# 	a = np.zeros_like( wAst )
# 	a[idxAst] = 1
# 	b = np.zeros_like( wAst )
# 	b[idxHat] = 1
# 	return np.linalg.norm( a - b, 1 )//2

Z = np.loadtxt( "train" )
# wAst = np.loadtxt( "wAstTest" )

y = Z[:,0]
X = Z[:,1:]

# y = Z[:,-1]
# X = Z[:,0:-1]


# # To avoid unlucky outcomes try running the code several times
# # numTrials = 5

# # Try various timeouts - the timeouts are in seconds
# timeouts = np.array( [0.1, 1, 2, 5] )

# # Try checking for timeout every 10 iterations
# spacing = 10

# result = np.zeros( len( timeouts ), 4 )

# for i in len( timeouts ):
# 	to = timeouts[i]
# 	avgObj = 0
# 	avgDist = 0
# 	avgSupp = 0
# 	avgTime = 0
# 	for t in range( numTrials ):
# 		(w, totTime) = solver( X, y, to, spacing )
# 		avgObj = avgObj + getObjValue( X, y, w )
# 		avgDist = avgDist + getModelError( w, wAst )
# 		avgSupp = avgSupp + getSupportError( w, wAst, k )
# 		avgTime = avgTime + totTime
# 	result[i, 0] = avgObj/numTrials
# 	result[i, 1] = avgDist/numTrials
# 	result[i, 2] = avgSupp/numTrials
# 	result[i, 3] = avgTime/numTrials

# np.savetxt( "result", result, fmt = "%.6f" )

# w initialization
w_0=np.ones(X.shape[1])*1

# Gives objective value
def getObjValue( X, y, wHat ):
    k = 1
    lassoLoss = k*np.linalg.norm( wHat, ord=1 )+pow( np.linalg.norm( X.dot( wHat ) - y, 2 ), 2 )
    return lassoLoss

# Returns Subgradient value

def sg(X,y,w,t):
    n=X.shape[0]
    # B=800
    # B_eff = min( B , n )

    # samples = random.sample(range(0, n), B_eff)
    # print(samples[1])
    # X_ = X[samples,:]
    # y_ = y[samples]
    k=1
    value=2*((X.T)@(X@w-y))+k*np.sign(w)
    return value

# Function for subgradient descent
def SubGD(X,y,w):
  tol=.00001
  w_f=w
  diff=1000000
  print (getObjValue(X,y,w))
  t=1
  eta_t=1
  n=X.shape[0]
  while diff>tol:
  
    g=sg(X,y,w,t)
    print(t)
    eta_t=.1/pow(t,1/2)
    w_new=w-(eta_t*g)
    w_f=np.vstack((w,w_new))
    # w_new=np.mean(w_f,axis=0)
    # print (getObjValue(X,y,w_new))
    diff=getObjValue( X, y, w )-getObjValue( X, y, w_new )
    # print(diff)
    a=w
    w=w_new
    t=t+1
  
  return (a,w_f)

(ans,w_final)=SubGD(X,y,w_0)
val=getObjValue(X,y,ans)

# ans
# val=getObjValue(X,y,ans)
w_final_m=w_final.mean(axis=0)

val

#gives top 20 coordinates by value
ans[abs(ans).argsort()[-20:][::-1]]

w_final_m[abs(w_final_m).argsort()[-20:][::-1]]

# Final w vector with only retaining top 20 coordinates rest are 0 
w_zero=np.zeros(1000)
w_zero[abs(ans).argsort()[-20:][::-1]]=ans[abs(ans).argsort()[-20:][::-1]]

# Getting index of top 20 coordinates 
abs(ans).argsort()[-20:][::-1]

np.argsort(abs(w_final_m))[-20:]

samp_ans = np.loadtxt( "/content/drive/My Drive/assn1 (1)/assn1/wAstTrain" )
#Getting coordinates of wAstTrain
np.argsort(abs(samp_ans))[-20:]

# Getting values 
print (samp_ans[np.argsort(abs(samp_ans))[-20:]])

getObjValue(X,y,samp_ans)

#printing coordinate which do not match

abs(w_final_m).argsort()[-20:][::-1][~np.isin(abs(w_final_m).argsort()[-20:][::-1],np.argsort(abs(samp_ans))[-20:])]

#Printing coordinate which do not match
abs(samp_ans).argsort()[-20:][::-1][~np.isin(abs(ans).argsort()[-20:][::-1],np.argsort(abs(samp_ans))[-20:])]



getModelError(w_zero,samp_ans)

getObjValue(X,y,w_final_m)

